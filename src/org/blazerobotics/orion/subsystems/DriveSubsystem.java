// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.blazerobotics.orion.subsystems;

import org.blazerobotics.orion.Robot;
import org.blazerobotics.orion.RobotMap;
import org.blazerobotics.orion.commands.*;
import org.blazerobotics.orion.util.MathUtil;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class DriveSubsystem extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController leftFrontMotor = RobotMap.driveSubsystemLeftFrontMotor;
    SpeedController leftBackMotor = RobotMap.driveSubsystemLeftBackMotor;
    SpeedController rightFrontMotor = RobotMap.driveSubsystemRightFrontMotor;
    SpeedController rightBackMotor = RobotMap.driveSubsystemRightBackMotor;
    RobotDrive drive = RobotMap.driveSubsystemDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public Encoder leftEncoder = RobotMap.driveSubsystemLeftEncoder;
    public Encoder rightEncoder = RobotMap.driveSubsystemRightEncoder;
    DoubleSolenoid pto = RobotMap.driveSubsystemPTO;
    DoubleSolenoid highGear = RobotMap.driveSubsystemHighGear;
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        setDefaultCommand(new DriveCommand());
    }

	public void tankDrive(double leftValue, double rightValue, boolean deadband, boolean equalize) {
		/*
		 * Deadband elimination
		 */
		if (deadband) {
			if (Math.abs(leftValue) < 0.05) {
				leftValue = 0;
			}
			if (Math.abs(rightValue) < 0.05) {
				rightValue = 0;
			}
		}
		
		/*
		 * Control equalizing
		 * 
		 * If left & right are a set distance from each other, average them
		 */
		if (equalize && MathUtil.distance(leftValue, rightValue) < 0.05) {
			rightValue = leftValue = MathUtil.average(leftValue, rightValue);
		}
		drive.tankDrive(leftValue, rightValue);
	}
	public void tankDrive(double left, double right) {
		tankDrive(left, right, false, true);
	}
	public void arcadeDrive(double turn, double throttle) {
		drive.arcadeDrive(turn, throttle);
	}
	/**
	 * Call this method every loop with the same distance
	 * @param dist the distance to drive
	 * @return if we are at the position
	 */
	public boolean drive(double dist) {
		double Pl = dist - leftEncoder.getDistance(); //Distance
		double Dl = leftEncoder.getRate();
		double Pr = dist - rightEncoder.getDistance(); //Distance
		double Dr = rightEncoder.getRate();
		double Cp = Robot.prefs.getDouble("kP", 0.01);
		double Cd = Robot.prefs.getDouble("kD", 0.0); // TODO make this stuff work.
		
		System.out.println(Pl + " Pl Pr" + Pr);
		
		double pidLeft = Pl * Cp - Dl * Cd;
		double pidRight = Pr * Cp - Dr * Cd;
		System.out.println(pidLeft + " pid " + pidRight);
		drive.tankDrive(pidLeft,
				pidRight);
		return Math.abs(pidLeft) < 0.05 && Math.abs(pidRight) < 0.05;
	}

	public void resetEncoders() {
		leftEncoder.reset();
		rightEncoder.reset();
		
	}
	public void setHighGear(boolean highGear) {
		this.highGear.set(highGear ? Value.kForward : Value.kReverse);
	}
	public void setPTO(boolean pto) {
		this.pto.set(pto ? Value.kReverse : Value.kForward);
	}
}